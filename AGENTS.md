# Depictionator — AGENTS.md

> このファイルは **Depictionator（世界観・資料集約 “Worldbuilding Atlas”）** の改善計画兼、実装時の「正しいやり方」をまとめた **コーディングエージェント向け指示書** です。  
> 目的は **既存のMVP実装（バックエンド中心・UIは最小）を、非エンジニア（多忙なデザイナー/ライター）が“講習なしで使える”プロダクト品質へ引き上げる** ことです。

---

## 0. まず守ること（Non‑negotiables）

### 0.1 ユーザー前提（最重要）
- 主な利用者は **非エンジニア**。システム講習に時間を割けない。
- したがってUIは **直感操作（ドラッグ&ドロップ / 直接操作 / すぐ結果が見える）** が必須。
- “設定画面で頑張る”ではなく、**作業画面で完結**させる（Progressive Disclosure）。

### 0.2 破壊しない（データ保全）
- **ハード削除禁止**。削除はソフトデリート + 復元。
- 主要オブジェクトは **監査ログ（audit）** と **差分/履歴（revision）** を残す。
- DBマイグレーションは後方互換を意識し、段階移行（expand → migrate → contract）。

### 0.3 “正史”と“視点情報”を混同しない
- 世界設定には「正史（Canon）」と「登場人物/陣営が信じる情報（Belief）」がある。
- Beliefには **誤認・虚偽・プロパガンダ** を扱える必要がある（信頼できない語り手）。

### 0.4 Wikipedia / Wikimedia 取り込みはライセンス最優先
- テキスト/画像の再利用は **出典URL・作者・ライセンス・取得日時** を必ず保存。
- PDF出力や共有画面では **TASL（Title/Author/Source/License）** 形式でクレジットを必ず出す。
- “画像”は Commons 由来でもライセンスが個別なので、**画像ごとに**権利情報を保持。

### 0.5 エージェント運用（Codex等）
- 変更は小さく、1 PR = 1 目的。
- まず現状把握（既存API/DB/画面の棚卸し）→ 影響範囲 → 実装 → テスト → 仕上げ。
- “動く”だけでなく、**非エンジニアの操作フロー**を必ず通してから完了とする。

---

## 1. 現状の前提（このリポジトリの土台）
- Next.js + TypeScript を前提（MVPとしてバックエンドのコアがある）。
- Postgres + Prisma を前提（docker-compose / docker compose が同梱）。
- PDF出力は Puppeteer を使う（`/api/pdf/export`）。
- LLMは Gemini（AI Studio / Vertex）と Codex CLI を切り替えられる前提（envで有効化）。

> ここから先の改善は **既存実装を最大限活かす**（全面刷新はしない）。  
> ただしUX達成のために必要なら、UI側の導線・状態管理・Canvas系コンポーネントは増設する。

---

## 2. プロダクトの核（North Star）
### 2.1 3つの主画面（最優先）
1. **World View（ワールド俯瞰）**
   - 入口ダッシュボード：地図 / タイムライン / 主要エンティティ / 最近更新 / “エビデンスボード” を1画面で。
2. **Article View（記事）**
   - 1つのエンティティに関する情報を集約（MD保存は維持しつつ、UIはブロック編集で直感化）。
3. **Map View（地図）**
   - 架空地図（画像）上にピン/動線/レイヤーを直感配置。章や時代で切り替える。

### 2.2 “非エンジニアが迷わない”成功条件
- 「新しい人物を登録 → 参考画像を貼る → 地図に置く → 関連人物と紐付け → PDFに出す」までを **数分で**実行できる。
- 主要操作は **ドラッグ&ドロップ**で完結：
  - エンティティを地図へドロップ → ピン作成
  - 画像/URLを記事へドロップ → 取り込み/引用作成
  - カードをボードへドロップ → 情報整理
- システム講習がなくても、**最初の30分で成果物が出る**UI。

---

## 3. データモデル方針（Prisma/DBの“正しい形”）

> 既存スキーマは尊重しつつ、足りない“運用機能”を拡張する。

### 3.1 追加（または明確化）すべきコア概念
- **Workspace / Project**：ゲームタイトル単位。権限もここに紐付く。
- **Entity**：人物/陣営/国家/場所/アイテム/出来事…（型 + テンプレ + メタ）。
- **Article**：Entityの本文（保存はMDを維持しつつ、内部はBlock JSONでも可）。
- **Map / MapLayer / Scene**：
  - Map：画像地図（世界→地域→都市の階層も可）
  - MapLayer：時代/視点で出し分ける集合
  - Scene：章/シーンの「地図状態スナップショット」（表示レイヤー、注目地点、動線）
- **Perspective（視点）**：Canon / Player / Faction / Character などのレンズ。
- **Era（時代）**：世界史上の区切り（期間）。“この時代に存在するものだけ”フィルタの基準。
- **EvidenceBoard**：エビデンス/リファレンス/メモを自由配置するキャンバス。
- **Reference / Citation**：文献・URL・画像の出典と、記事・ボード・PDFへの紐付け。
- **AuditLog / Revision**：編集履歴・差分・誰が何をしたか。
- **Review / Approval**：下書き→レビュー→承認の状態遷移。
- **Watch / Notification / ReadState**：ウォッチ、更新通知、既読。

### 3.2 “正史”と“視点情報”の実装戦略（段階）
**Phase 1（現実的・すぐ効く）**
- Canon本文（Article）に対して、視点/時代ごとの **Overlay（追記/注釈）** を別テーブルで持つ。
  - 例：`ArticleOverlay(articleId, perspectiveId, eraId?, bodyMd, reliability, notes)`
- UI上は「レンズ選択（Era + Perspective）」で合成表示。
- “誤認”は Overlay に `reliability = "false_belief"` 等を持たせ、表示上の表現（警告/色/ラベル）で明確化。

**Phase 2（必要になったら）**
- 記事をブロック化し、ブロック単位に visibility（era/perspective/reliability）を付ける。
- これはUXと実装コストが跳ねるので、Phase 1で運用が回るか必ず検証してから進める。

---

## 4. UX実装の最重要ポイント（ここが弱いと失敗する）

### 4.1 Map View：直感操作の必須要件
**“置くだけで動く”**を満たすこと。

- **エンティティ一覧 → 地図へドラッグ → 自動でピン作成**
- ピンは **ドラッグで移動**、複数選択、スナップ/整列（ガイド）を用意
- 動線（Path）は **描くだけ**：
  - “開始地点”→“終点”をクリック/ドラッグで線ができる
  - 矢印/点線/太さ/色はプリセット（選ぶだけ）
- 章/シーンでの切替：
  - Sceneを選ぶと、表示レイヤー/動線/注目地点が復元される
- 迷子防止：
  - “現在のレンズ（Era/Perspective）”を常に画面上部に固定表示

> 架空地図（画像）座標は “地理座標” ではなく “画像座標（ピクセル系）” を基本にする（LeafletのCRS.Simpleなどの方式が典型）。

### 4.2 Evidence Board：必須（別機能としても、地図のサブとしても）
- “エビデンスボード”は **当然必要**（要件）。
- 目的：非エンジニアが **断片情報を置いて、線で繋いで、俯瞰で理解する**。
- 必須機能：
  - カード（Entity / 画像 / URL / 引用 / メモ / タグ）を自由配置
  - 線で接続（矢印/注釈）
  - グループ化/フレーム（章、陣営、論点、時代…）
  - 画像の切り抜き/キャプション（軽量で良い）
  - “このカードの出典”が必ず辿れる（Reference紐付け）
- 実装候補：
  - **tldraw**（whiteboard SDK）または **Excalidraw** を埋め込み、カードをカスタム拡張する
  - もしくは、ノードベースUI（React Flow）で最小を作る

> ただし、ユーザーが求めるのは“ワークフロー図”ではなく“ムードボード/証拠壁”なので、UX的には whiteboard SDK を優先する。

### 4.3 Article View：MDを維持しつつ “ブロック編集UX” に寄せる
- 永続形式はMDでもよいが、編集体験は **Notion / Google Docs寄り**にする：
  - 画像D&D、カード埋め込み、引用ブロック、脚注/出典
  - エンティティ参照（@Character 等）でリンク作成
- 最低限の自動化：
  - テンプレ（人物/国家/陣営/場所/アイテム）から見出し生成
  - “関連”の自動抽出（バックリンク、タグ、登場イベント）

---

## 5. Wikipedia / Wikidata インポート（効率化 + コンプライアンス）

### 5.1 取り込みフロー（UX）
- 入力：URL または タイトル（言語選択）
- まず **プレビュー**：
  - 概要（サマリ）
  - 代表画像（あれば）
  - カテゴリ/関連リンク（任意）
- “取り込み”はワンクリックで：
  - Entity作成（テンプレ適用）
  - Articleに引用ブロックとして挿入（必要最小限）
  - Referenceを自動作成（出典・取得日・ライセンス）
  - 画像を取り込む場合：画像ごとに author/license/source を保存

### 5.2 実装（API選定）
- 基本は **Wikimedia / MediaWiki の REST API** を使う（検索・サマリ・ページ）。
- 必要に応じて Action API（`action=query`）や Wikidata REST を補助で使う。
- 取得したデータはキャッシュし、同一URLの連打で外部APIを叩かない。

### 5.3 ライセンス実装（必須）
- `Reference` と `Asset` に以下を必ず保存：
  - title / author / sourceUrl / licenseId / licenseUrl / retrievedAt / attributionText
- PDF出力時は「クレジット一覧ページ」を末尾に自動付与（TASL）。

---

## 6. 文献管理（Bibliography）と “知識の足場” の作り方

### 6.1 Referenceライブラリ（Zotero-lite）
- 目的：世界観が大規模化したとき、**根拠が失われない**ようにする。
- Referenceは URL / 書籍 / PDF / 画像 / 社内資料（ファイル）を扱う。
- 取り込み：
  - DOI / BibTeX / RIS / URL / Wikidata などからメタデータ生成（可能なら）
- UI：
  - Reference一覧（タグ/著者/年/種類）
  - Reference詳細（メモ、紐付くEntity/記事/ボード/イベント）
  - “この情報はどこから来た？”がワンクリックで追える

### 6.2 Citation（記事・PDFと接続）
- 記事本文に出典を挿入できる（脚注または引用カード）。
- PDF出力には自動で脚注/文献一覧を生成する。

---

## 7. ナレッジベース（検索・関連・RAG）

### 7.1 まずは “強い検索” を作る（最優先）
- 非エンジニアはUIより先に **検索**で詰まる。ここを最速で強化する。
- 最低限：
  - タイトル/別名/タグ/本文/出典/画像キャプション を横断検索
  - 絞り込み：EntityType / Era / Perspective / Status（draft/approved）
  - 最近更新 / 自分の担当 / ウォッチ中 のクイックフィルタ

### 7.2 “知識ベース”としての関連性
- バックリンク（どこから参照されているか）
- 関連候補（同タグ、同陣営、同地点、同イベント）
- 余力が出たら：
  - ベクトル検索（埋め込み）で “意味検索”
  - LLMによる “要約・比較・矛盾検出” を補助（ただし人が最終判断）

---

## 8. LLM統合（Gemini / Codex CLI）— 正しい組み込み方

### 8.1 UI：常設の LLM パネル
- どの画面でも開ける右ドロワー（LLM Panel）。
- “生成して終わり”ではなく、**結果を安全に反映**できることが重要。

### 8.2 生成を安全にする（Structured Output + Tooling）
- LLMは **JSON Schema 等の構造化出力**を基本にし、アプリ側で検証してから反映する。
- 例：地図ピン生成、イベント作成、記事テンプレ生成、Reference生成。
- “自動反映”は必ず段階的に：
  1) 提案（下書き）生成
  2) 差分レビュー
  3) 承認して反映

### 8.3 ログと監査
- LLM実行ログ：誰が、どのコンテキストで、何を依頼し、何が返り、何を反映したか。
- 外部APIキーは **絶対にクライアントへ出さない**（サーバ側で保持）。

### 8.4 Codex CLI 実行（サーバ側）
- `codex` は強力なので、実行は allowlist / timeout / workspace制限を必須にする。
- 実行結果はすべてログ化し、失敗時に再現できる情報を残す。

---

## 9. PDF出力（“現場で使える”印刷物）

### 9.1 印刷セット（Print Pack）ビルダー
- 記事/地図/タイムライン/ボード をドラッグして並べ、テンプレを選んでPDF化。
- 必須：
  - 目次
  - ページ番号
  - 参照リンク（最低限の内部参照）
  - クレジット一覧（外部コンテンツ）

### 9.2 実装原則
- PDFは Puppeteer（HTML/CSS → PDF）を基盤にする。
- レイアウトは “印刷”が目的：フォント/余白/改ページ制御を持つ。

---

## 10. 運用機能（チーム利用に必要）

### 10.1 権限（RBAC）
- Workspace単位で：viewer / editor / admin（まずは3段階）
- 可能なら：EntityType / MapLayer / Perspective ごとに権限を細分化（Phase 2）

### 10.2 レビュー（合意形成）
- draft → in_review → approved の状態
- コメント、メンション、差分表示
- 承認者の記録

### 10.3 ウォッチ/既読/通知
- Watch：Entity/Article/Map/Board/Event を購読
- 既読：ユーザー単位で “最後に見たリビジョン” を保持
- 通知：アプリ内通知 +（必要なら）メール/SlackはPhase 2

---

## 11. 実装ロードマップ（既存実装を引き上げる順番）

> 大事なのは「全部同時にやらない」こと。  
> まず非エンジニアUXの詰まり（Map/Board/Search）を最優先で解消する。

### Phase 0：棚卸し（必須）
- 既存DBモデル、API、画面、LLM、PDFの実装を一覧化（1枚でわかるドキュメント）。
- “今できること/できないこと”をUI視点で整理（ユーザーフローで）。

### Phase 1：UX土台
- World View（入口）を作る：検索 + 最近更新 + 地図/タイムラインのショートカット
- レンズ（Era/Perspective）をグローバルUIに固定
- “新規作成”の導線を統一（テンプレ選択 → 作成 → 次アクション提案）

### Phase 2：Map View をプロダクト品質へ
- D&Dでピン作成、ドラッグで移動、複数選択
- 動線（矢印）作成を“描くだけ”に
- Scene（章）スナップショット
- フィルタ（Era/Perspective/Layer）

### Phase 3：Evidence Board（必須）
- Whiteboard SDK 埋め込み（tldraw / Excalidraw など）
- カード（Entity/Asset/Reference/Note）を配置・接続
- 出典（Reference）との紐付け
- ボード→PDF/画像エクスポート

### Phase 4：Wikipedia/Wikidata import
- URL入力→プレビュー→1クリック取り込み
- Reference/Asset のライセンス情報自動保存
- 取り込みテンプレ（人物/地名/組織）へ割当

### Phase 5：文献管理（Reference/Citation）
- ReferenceライブラリUI
- 記事本文への引用挿入
- PDFの文献一覧/クレジット自動生成

### Phase 6：Knowledge Base 強化（検索 + 関連 + RAG）
- DB全文検索（まずはキーワード）
- 関連候補、バックリンク
- 余力でベクトル検索 + LLM補助（要約/比較）

### Phase 7：運用機能（監査/レビュー/通知）
- AuditLog / Revision の整備
- Reviewフロー
- Watch / ReadState / Notification

---

## 12. Definition of Done（必ず満たす）

### 12.1 UX DoD（非エンジニア向け）
- 主要フロー（人物登録→地図配置→資料貼付→PDF）を、説明なしで辿れる。
- 失敗しても戻れる（Undo/Cancel/復元、少なくともソフトデリート）。
- 空状態（データがない）でも次にやることが明確（Empty State設計）。

### 12.2 技術 DoD
- Prisma migration が安全（本番で壊れない）
- APIは入力検証（zod等） + 権限チェック + 監査ログ
- 主要画面にE2E（Playwright等）または最低限の統合テストを追加
- PDF出力は再現性（フォント/改ページ/クレジット）を担保

---

## 13. すぐ使える開発コマンド（README準拠）
```bash
# local
cp .env.example .env
docker-compose up -d db
npm install
npx prisma generate
npx prisma migrate dev --name init
npm run dev
curl http://localhost:3000/health

# docker (app + db)
docker compose up --build
```

---

## 14. エージェントへのお願い（作業の進め方）
- **必ず最初に**：現状の実装を読んで、既存の流儀（フォルダ構成/命名/パターン）に合わせる。
- 迷ったら、まずは “UXで詰まっている点（Map/Board/Search）” を優先する。
- 新規依存を入れる場合は、以下を説明すること：
  - なぜ必要か（ユーザーフローのどこが改善されるか）
  - 代替案と比較
  - ライセンス / バンドルサイズ / 保守性

---

（EOF）
